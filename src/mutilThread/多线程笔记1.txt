当调用JAVA虚拟机将java文件编译成class文件的时候，在JAVA VM启动的时候会有一个进程
 java.exe,该进程中至少一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中，
 该线程称之为主线程。其实JVM,启动的还有垃圾回收机制线程。
 多线程的出现，能使多部分代码同时运行
 
                
     java程序：
         |       ->垃圾回收机制
         |<------
         |       ->主函数的代码
         |
     JVM------> 机器可识别的代码---->执行代码的效果。  
 
 
	
	
	--------------------------------
	
创建线程的第一种方式：
	  1：定义类继承Thread.
	  2:复写Thread类中的run方法。
	        目的:将自定义的代码存储在run方法中
	  3:调用线程的start的方法
	        该方法有两个作用：启动线程，调用run方法
	
	
	注意：不启动start()方法，调用run和启用start()方法的区别
	
	---------------------------------------------
	  线程的几种状态：
	  start()
	  sleep(time)
	  wait()   <----notify()
	  stop()    run方法结束    
	
	 *****************************
	 线程都有自己的名称：
	 1：调用getName()方法
	 2：类Thread中有一个方法currentThread()能够返回当前真在执行的线程，是静态的。
	   设置线程名称：setName或者构造函数
	
	
	-----------------------------------
  创建线程的第二种方法：实现Runnable接口
    步骤：
     1：定义l；类实现Runnable接口
     2:覆盖Runnable接口中的run方法，将线程要运行的代码放在读run方法中
                       
     3：通过Thread类建立线程对象，函数参数是定义的类的对象
     4：将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。
                    因为，自定义的run方法所属的对象是Runnable接口的子类对象
                    所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象
   
     实现的好处是：避免单继承的局限性
     在定义线程是，建议使用实现方式      
           
          重中之重的问题：Runnable的这个特点的实现方式跟继承有什么区别：
                   因为一个类不能实现多继承，所以，一旦一个类继承了Thread类，就不能再继承其它的类，这样子
                     所造成的有一定的局限性，所以就出项了Runnable这个接口，来避免一个类要成为线程类时直接集成Thread
      所以这两种方式的区别是：
      　１：继承Ｔｈｒｅａｄ　：线程代码存放的Ｔｈｒｅａｄ子类ｒｕｎ方法中
     　２：实现Ｒｕｎｎａｂｌｅ，线程代码存在接口子类的ｒｕｎ方法   
           
           
线程的安全问题：
  如果不限制线程的话，有可能因为在争夺资源的过程中会出现问题 。
  多线程的运行出现安全问题：
   当运行多条语句在操作 同享数据时，一个线程对应多条语句只执行了一部分，还没有执行完，另一个行线程参与
           
           synchronized(d)
           
     进来执行，导致共享数据的错误
解决的办法：
  对多条操作共享数据的语句，只能让一个线程都执行完，执行过程中，其他线程不可以参与执行。
JAVA对于多线程的安全问题提供饿了专业的决解方式，：就是同步代码块。
synchronized(对象)
{
多个线程共享数据的操作语句
}
对象如同锁，持有锁的线程可以在同步中执行，
没有锁的线程即使获取CPU的执行权，也进不去，因为没有获取锁。
 火车上的卫生间----经典。
同步的前提：
 1：必须要有两个或者两个以上的线程。
2：必须是多个线程使用同一个锁。
必须保证同步中只能有一个线程在运行。
好处：
解决了多线程分安全问题：
弊端:多个线程需要判断锁，较为消耗资源。 

//需求：
银行有一个小金库
有两个储户分别存300元，每次存100元，存3次。
目的：该程序是否有安全问题，如果有如何解决:
//解析，每个储户就是一个线程:

如何找问题：
1：明确哪些代码是多线程运行代码；
2：明确共享数据
3：明确多线程运行中哪些代码是操作共享数据的
实现同步的方法有两种：
1：同步代码块
2：同步函数（同步方法）
同步函数调用的是哪一个锁：
函数需要被对象调用，那么函数都有一个所属对象引用。就是this。
所以同步函数是

程序代码描述如下：
  class Bank
{
private int sum;
//Object=obj=new Object();
public  synchronized void add(int n)
{
//synchronized(obj)
//{
 sum=sum+n;
try{Thread.sleep(10;)}
catch(Exception e){}
System.out.println("sum="+sum);
//}
}

}
class Cus implements Runnable
//实现这个接口的目的是创建线程（需要在后面跟Thread这个类关联起来）
{
private Bank b=new Bank();
     public void run()//这是线程要跑的代码块
   {
         for(int x=0,x<3;x++)//定义在run方法里面的变量都是局部变量，每个线程都拥有的东西。
        {
        b.add(1000);
        }
   }

}
class BankDemo
{
public static void  main(String[] args)
{
Cus c=new Cus();
Thread t1=new Thread(c);
Thread t2=new Thread(c);
t2.start();
t1.start();

}

}
           
           死锁：同步中的嵌套
           
           
           
   对于多 个生产者和消费者        